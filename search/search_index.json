{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"iiif-prezi3 IIIF Presentation API 3 Python Library Installation PyPi The easiest way to install the iiif-prezi3 library is directly from PyPi: pip install iiif-prezi3 Manual installation Alternatively, you can clone the repository and run setup.py locally: git clone https://github.com/iiif-prezi/iiif-prezi3.git or git clone git@github.com:iiif-prezi/iiif-prezi3.git followed by: cd iiif-prezi3 python setup.py install Basic Usage You can now import the library or individual classes from within Python and start creating your IIIF Presentation 3 objects: Directly creating a Manifest >>> from iiif_prezi3 import Manifest >>> m = Manifest(id=\"https://example.com/iiif/manifest.json\", type=\"Manifest\", label={\"en\":[\"Example Manifest\"]}) >>> print(m.json(indent=2)) { \"@context\": \"http://iiif.io/api/presentation/3/context.json\", \"id\": \"https://example.com/iiif/manifest.json\", \"type\": \"Manifest\", \"label\": { \"en\": [ \"Example Manifest\" ] } } Importing an existing IIIF Manifest If you have an existing IIIF Presentation v3 Manifest, you can load it via the built-in json module and create the objects: >>> from iiif_prezi3 import Manifest >>> import json >>> manifest_json = json.load(open(\"example.json\")) >>> m = Manifest(**manifest_json) >>> print(m.json(indent=2)) { \"@context\": \"http://iiif.io/api/presentation/3/context.json\", \"id\": \"https://iiif.io/api/cookbook/recipe/0003-mvm-video/manifest.json\", \"type\": \"Manifest\", \"label\": { \"en\": [ \"Video Example 3\" ] }, \"items\": [ { \"id\": \"https://iiif.io/api/cookbook/recipe/0003-mvm-video/canvas\", \"type\": \"Canvas\", \"height\": 360, \"width\": 640, \"duration\": 572.034, \"items\": [ { \"id\": \"https://iiif.io/api/cookbook/recipe/0003-mvm-video/canvas/page\", \"type\": \"AnnotationPage\", \"items\": [ { \"id\": \"https://iiif.io/api/cookbook/recipe/0003-mvm-video/canvas/page/annotation\", \"type\": \"Annotation\", \"motivation\": \"painting\", \"body\": { \"id\": \"https://fixtures.iiif.io/video/indiana/lunchroom_manners/high/lunchroom_manners_1024kb.mp4\", \"type\": \"Video\", \"height\": 360, \"width\": 480, \"duration\": 572.034, \"format\": \"video/mp4\" }, \"target\": \"https://iiif.io/api/cookbook/recipe/0003-mvm-video/canvas\" } ] } ] } ] } Extensions iiif-prezi3 includes the capability to load extensions to the IIIF Presentation schema (e.g navPlace ) and modify the library's Python classes to include extra properties, validation, helper methods, etc. Published extensions from the IIIF Registry of Extensions are included with the package, and can be loaded using the iiif_prezi3.load_bundled_extensions() method. Called without argument, this method will load all bundled extensions listed in the iiif_prezi3/config/extensions.json file. If you wish to only load selected extensions from those available bundled with the library, you can pass either the path to a JSON file, or a list of extension names as an argument to the function: >>> import iiif_prezi3 >>> iiif_prezi3.load_bundled_extensions(extensions=\"/path/to/chosen_extensions.json\") >>> import iiif_prezi3 >>> iiif_prezi3.load_bundled_extensions(extensions=['example_extension']) Extensions work in much the same way as helper methods, and are monkeypatched into the relevant objects in the iiif_prezi3.skeleton class, from which everything is loaded. For a simple example, please see the extensions/example_extension.py file, and the documentation on writing a helper method . Local Development For developing iiif-prezi3 locally, clone the repo and then install it and the development dependencies using pip's \"editable mode\": git clone git@github.com:iiif-prezi/iiif-prezi3.git cd iiif-prezi3 pip install -e . [ dev ] Running Tests Tests (including linting) can be run using tox . First, install tox with pip install tox , then type tox . Versioning iiif-prezi3 broadly follows Semantic Versioning . Patch releases are used for bug fixes, minor releases add new functionality and maintain backwards compatibility, and major versions contain breaking changes to the public API of the library. Links to the changes between individual versions can be found on the releases page.","title":"README"},{"location":"#iiif-prezi3","text":"IIIF Presentation API 3 Python Library","title":"iiif-prezi3"},{"location":"#installation","text":"","title":"Installation"},{"location":"#pypi","text":"The easiest way to install the iiif-prezi3 library is directly from PyPi: pip install iiif-prezi3","title":"PyPi"},{"location":"#manual-installation","text":"Alternatively, you can clone the repository and run setup.py locally: git clone https://github.com/iiif-prezi/iiif-prezi3.git or git clone git@github.com:iiif-prezi/iiif-prezi3.git followed by: cd iiif-prezi3 python setup.py install","title":"Manual installation"},{"location":"#basic-usage","text":"You can now import the library or individual classes from within Python and start creating your IIIF Presentation 3 objects:","title":"Basic Usage"},{"location":"#directly-creating-a-manifest","text":">>> from iiif_prezi3 import Manifest >>> m = Manifest(id=\"https://example.com/iiif/manifest.json\", type=\"Manifest\", label={\"en\":[\"Example Manifest\"]}) >>> print(m.json(indent=2)) { \"@context\": \"http://iiif.io/api/presentation/3/context.json\", \"id\": \"https://example.com/iiif/manifest.json\", \"type\": \"Manifest\", \"label\": { \"en\": [ \"Example Manifest\" ] } }","title":"Directly creating a Manifest"},{"location":"#importing-an-existing-iiif-manifest","text":"If you have an existing IIIF Presentation v3 Manifest, you can load it via the built-in json module and create the objects: >>> from iiif_prezi3 import Manifest >>> import json >>> manifest_json = json.load(open(\"example.json\")) >>> m = Manifest(**manifest_json) >>> print(m.json(indent=2)) { \"@context\": \"http://iiif.io/api/presentation/3/context.json\", \"id\": \"https://iiif.io/api/cookbook/recipe/0003-mvm-video/manifest.json\", \"type\": \"Manifest\", \"label\": { \"en\": [ \"Video Example 3\" ] }, \"items\": [ { \"id\": \"https://iiif.io/api/cookbook/recipe/0003-mvm-video/canvas\", \"type\": \"Canvas\", \"height\": 360, \"width\": 640, \"duration\": 572.034, \"items\": [ { \"id\": \"https://iiif.io/api/cookbook/recipe/0003-mvm-video/canvas/page\", \"type\": \"AnnotationPage\", \"items\": [ { \"id\": \"https://iiif.io/api/cookbook/recipe/0003-mvm-video/canvas/page/annotation\", \"type\": \"Annotation\", \"motivation\": \"painting\", \"body\": { \"id\": \"https://fixtures.iiif.io/video/indiana/lunchroom_manners/high/lunchroom_manners_1024kb.mp4\", \"type\": \"Video\", \"height\": 360, \"width\": 480, \"duration\": 572.034, \"format\": \"video/mp4\" }, \"target\": \"https://iiif.io/api/cookbook/recipe/0003-mvm-video/canvas\" } ] } ] } ] }","title":"Importing an existing IIIF Manifest"},{"location":"#extensions","text":"iiif-prezi3 includes the capability to load extensions to the IIIF Presentation schema (e.g navPlace ) and modify the library's Python classes to include extra properties, validation, helper methods, etc. Published extensions from the IIIF Registry of Extensions are included with the package, and can be loaded using the iiif_prezi3.load_bundled_extensions() method. Called without argument, this method will load all bundled extensions listed in the iiif_prezi3/config/extensions.json file. If you wish to only load selected extensions from those available bundled with the library, you can pass either the path to a JSON file, or a list of extension names as an argument to the function: >>> import iiif_prezi3 >>> iiif_prezi3.load_bundled_extensions(extensions=\"/path/to/chosen_extensions.json\") >>> import iiif_prezi3 >>> iiif_prezi3.load_bundled_extensions(extensions=['example_extension']) Extensions work in much the same way as helper methods, and are monkeypatched into the relevant objects in the iiif_prezi3.skeleton class, from which everything is loaded. For a simple example, please see the extensions/example_extension.py file, and the documentation on writing a helper method .","title":"Extensions"},{"location":"#local-development","text":"For developing iiif-prezi3 locally, clone the repo and then install it and the development dependencies using pip's \"editable mode\": git clone git@github.com:iiif-prezi/iiif-prezi3.git cd iiif-prezi3 pip install -e . [ dev ]","title":"Local Development"},{"location":"#running-tests","text":"Tests (including linting) can be run using tox . First, install tox with pip install tox , then type tox .","title":"Running Tests"},{"location":"#versioning","text":"iiif-prezi3 broadly follows Semantic Versioning . Patch releases are used for bug fixes, minor releases add new functionality and maintain backwards compatibility, and major versions contain breaking changes to the public API of the library. Links to the changes between individual versions can be found on the releases page.","title":"Versioning"},{"location":"add-reference-to-manifest-inside-a-collection/","text":"How to add references to manifest inside a collection iif-prezi3 offer some helper methods for adding a reference to manifests and collection inside collections. Reference to manifests inside collections can not contain the items property while label, id and type are required (see APIs for more). Using iiif_prezi3 this can be done as follows: import iiif_prezi3 mycollection = iiif_prezi3 . Collection ( id = 'http://iiif.example.org/prezi/Collection/0' , type = 'Collection' ) myrefmanifest = mycollection . add_manifest_reference_to_items ( manifest_id = 'http://iiif.example.org/prezi/Manifest/0' , label = { 'en' : 'default label' }) This will return a a collection object with a reference to a manifest inside the items property: print ( mycollection . json ( exclude_unset = True , indent = 2 )) { \"id\": \"http://iiif.example.org/prezi/Collection/0\", \"type\": \"Collection\", \"items\": [ { \"id\": \"http://iiif.example.org/prezi/Manifest/0\", \"label\": {}, \"type\": \"Manifest\" } ] }","title":"Add reference to manifest inside a collection"},{"location":"add-reference-to-manifest-inside-a-collection/#how-to-add-references-to-manifest-inside-a-collection","text":"iif-prezi3 offer some helper methods for adding a reference to manifests and collection inside collections. Reference to manifests inside collections can not contain the items property while label, id and type are required (see APIs for more). Using iiif_prezi3 this can be done as follows: import iiif_prezi3 mycollection = iiif_prezi3 . Collection ( id = 'http://iiif.example.org/prezi/Collection/0' , type = 'Collection' ) myrefmanifest = mycollection . add_manifest_reference_to_items ( manifest_id = 'http://iiif.example.org/prezi/Manifest/0' , label = { 'en' : 'default label' }) This will return a a collection object with a reference to a manifest inside the items property: print ( mycollection . json ( exclude_unset = True , indent = 2 )) { \"id\": \"http://iiif.example.org/prezi/Collection/0\", \"type\": \"Collection\", \"items\": [ { \"id\": \"http://iiif.example.org/prezi/Manifest/0\", \"label\": {}, \"type\": \"Manifest\" } ] }","title":"How to add references to manifest inside a collection"},{"location":"code/","text":"Code reference","title":"Code reference"},{"location":"code/#code-reference","text":"","title":"Code reference"},{"location":"generate-schema/","text":"Generating the Schema Install the datamodl-codegen program which will convert a JSON schema into python code. Either follow the instructions here or run: pip install datamodel-code-generator Then in the iiif-prezi3 code directory run: datamodel-codegen --input ../../iiif/presentation-validator/schema/iiif_3_0.json --input-file-type jsonschema --use-default --base-class base.Base --output skeleton.py Replacing the path to your iiif schema file with where ever you have downloaded the iiif_3_0.json file.","title":"Generating the Schema"},{"location":"generate-schema/#generating-the-schema","text":"Install the datamodl-codegen program which will convert a JSON schema into python code. Either follow the instructions here or run: pip install datamodel-code-generator Then in the iiif-prezi3 code directory run: datamodel-codegen --input ../../iiif/presentation-validator/schema/iiif_3_0.json --input-file-type jsonschema --use-default --base-class base.Base --output skeleton.py Replacing the path to your iiif schema file with where ever you have downloaded the iiif_3_0.json file.","title":"Generating the Schema"},{"location":"getting-started-using-iiifprezi3-without-helpermethods/","text":"Getting started: using iiifprezi3 without helper methods Note iiif-prezi3 offers useful helper methods for adding IIIF resources, it is preferable to use them when possible. For special needs, not addressed by the helper methods, users may take advantage directly of the Python classes generated by datamodel-code-generator . These classes can be used for generating instances of IIIF objects described in the presentation API v.3. In the following lines of code, we will create a manifest and two canvases using directly the pydantic classes: import iiif_prezi3 amanifest = iiif_prezi3 . Manifest ( id = 'http://iiif.example.org/prezi/Manifest/0' , label = { 'en' : [ 'default label' ]}) acanvas = iiif_prezi3 . Canvas ( id = 'http://iiif.example.org/prezi/Manifest/0/canvas/01' , label = { 'en' : [ 'default label' ]}) asecondcanvas = iiif_prezi3 . Canvas ( id = 'http://iiif.example.org/prezi/Manifest/0/canvas/02' , label = { 'en' : [ 'second label' ]}) For constructing nested objects we have to assign to the items property a list containing the valid IIIF objects accepted by the class: amanifest . items = [ acanvas , asecondcanvas ] If we try to set the items property of the manifest items to a string pydantic will rise a ValidationError : amanifest . items = [ \"this shouldn't be here\" ] Warning Be aware that appending to the items list after that the items property has been assigned : amanifest . items . append ( \"this shouldn't be here\" ) will not raise any error regarding the input. print ( amanifest . json ( exclude_unset = True , indent = 2 )) { \"id\": \"http://iiif.example.org/prezi/Manifest/0\", \"type\": \"Manifest\", \"label\": {}, \"items\": [ { \"id\": \"http://iiif.example.org/prezi/Manifest/0/canvas/01\", \"type\": \"Canvas\", \"label\": {} }, { \"id\": \"http://iiif.example.org/prezi/Manifest/0/canvas/02\", \"type\": \"Canvas\", \"label\": {} }, \"this shouldn't be here\" ] } Of course, in most of the use cases, canvases will be created dynamically so a possible approach for constructing the manifest can be the following: canvases = [] for i in range ( 3 ): canvasid = f 'http://iiif.example.org/prezi/CanvasID/ { i } ' aservice = { \"id\" : \"https://example.org/iiif/book1/page2\" , \"type\" : \"ImageService3\" , \"profile\" : \"level2\" } anannotation = iiif_prezi3 . Annotation ( type = 'Annotation' , id = canvasid + '/annotation/0' , target = canvasid ) anannotation . motivation = 'painting' # aresource = Resource(service=[aservice],type='Resource') anannotation . body = iiif_prezi3 . ResourceItem ( service = [ aservice ], id = canvasid + '/annotation/resource' , type = 'Image' ) anannotationpage = iiif_prezi3 . AnnotationPage ( type = 'AnnotationPage' ) anannotationpage . items = [ anannotation ] acanvas . items = [ anannotationpage ] canvases . append ( acanvas ) amanifest . items = canvases Notice that the canvases list is created at the beginning but is assigned to the items property of the manifest only once at the end, in this way pydantic will validate the list. Warning Keep in mind that objects contained in the canvases list are references in the manifest items, hence any modification on the original object will affect the object inside the manifest. This holds true for any object added to the model.","title":"Using iiifprezi3 without helper methods"},{"location":"getting-started-using-iiifprezi3-without-helpermethods/#getting-started-using-iiifprezi3-without-helper-methods","text":"Note iiif-prezi3 offers useful helper methods for adding IIIF resources, it is preferable to use them when possible. For special needs, not addressed by the helper methods, users may take advantage directly of the Python classes generated by datamodel-code-generator . These classes can be used for generating instances of IIIF objects described in the presentation API v.3. In the following lines of code, we will create a manifest and two canvases using directly the pydantic classes: import iiif_prezi3 amanifest = iiif_prezi3 . Manifest ( id = 'http://iiif.example.org/prezi/Manifest/0' , label = { 'en' : [ 'default label' ]}) acanvas = iiif_prezi3 . Canvas ( id = 'http://iiif.example.org/prezi/Manifest/0/canvas/01' , label = { 'en' : [ 'default label' ]}) asecondcanvas = iiif_prezi3 . Canvas ( id = 'http://iiif.example.org/prezi/Manifest/0/canvas/02' , label = { 'en' : [ 'second label' ]}) For constructing nested objects we have to assign to the items property a list containing the valid IIIF objects accepted by the class: amanifest . items = [ acanvas , asecondcanvas ] If we try to set the items property of the manifest items to a string pydantic will rise a ValidationError : amanifest . items = [ \"this shouldn't be here\" ] Warning Be aware that appending to the items list after that the items property has been assigned : amanifest . items . append ( \"this shouldn't be here\" ) will not raise any error regarding the input. print ( amanifest . json ( exclude_unset = True , indent = 2 )) { \"id\": \"http://iiif.example.org/prezi/Manifest/0\", \"type\": \"Manifest\", \"label\": {}, \"items\": [ { \"id\": \"http://iiif.example.org/prezi/Manifest/0/canvas/01\", \"type\": \"Canvas\", \"label\": {} }, { \"id\": \"http://iiif.example.org/prezi/Manifest/0/canvas/02\", \"type\": \"Canvas\", \"label\": {} }, \"this shouldn't be here\" ] } Of course, in most of the use cases, canvases will be created dynamically so a possible approach for constructing the manifest can be the following: canvases = [] for i in range ( 3 ): canvasid = f 'http://iiif.example.org/prezi/CanvasID/ { i } ' aservice = { \"id\" : \"https://example.org/iiif/book1/page2\" , \"type\" : \"ImageService3\" , \"profile\" : \"level2\" } anannotation = iiif_prezi3 . Annotation ( type = 'Annotation' , id = canvasid + '/annotation/0' , target = canvasid ) anannotation . motivation = 'painting' # aresource = Resource(service=[aservice],type='Resource') anannotation . body = iiif_prezi3 . ResourceItem ( service = [ aservice ], id = canvasid + '/annotation/resource' , type = 'Image' ) anannotationpage = iiif_prezi3 . AnnotationPage ( type = 'AnnotationPage' ) anannotationpage . items = [ anannotation ] acanvas . items = [ anannotationpage ] canvases . append ( acanvas ) amanifest . items = canvases Notice that the canvases list is created at the beginning but is assigned to the items property of the manifest only once at the end, in this way pydantic will validate the list. Warning Keep in mind that objects contained in the canvases list are references in the manifest items, hence any modification on the original object will affect the object inside the manifest. This holds true for any object added to the model.","title":"Getting started: using iiifprezi3 without helper methods"},{"location":"write-helper-method/","text":"Helper methods Helper methods in iiif-prezi3 allow functionality for common use cases to be included in the package. Helpers that are general can be loaded and used by the user as required, and those that target specific schema objects (e.g a helper to add a Canvas to a Manifest) are monkeypatched onto the relevant schema class at load time. Location and structure Helper methods should be located in Python files inside the helpers/ directory. Direct helper methods that take schema objects as arguments can be singular functions, whereas those which are designed to add new functions or properties to existing schema classes must themselves be containing inside a class, to enable them to be monkeypatched in correctly. Accessing Schema Objects Relevant schema classes can be loaded from the skeleton.py file in the main iiif-prezi3 package by using a relative import: from ..skeleton import Manifest Monkeypatching onto Schema classes If the helper targets a class from the main IIIF Presentation 3 schema, then it can be monkeypatched onto that class at runtime using the iiif_prezi3.loader.monkeypatch_schema() method. This function takes two arguments: the class to target, and the class(es) containing the helper methods, either as a single object or a list. Add the monkeypatch function call at the end of your helper file, and it will be run when the helper file is imported by the main package (as detailed below). from ..skeleton import Manifest from ..loader import monkeypatch_schema class MyHelper : def helper_function ( self ): return \"I am a Manifest helper\" monkeypatch_schema ( Manifest , MyHelper ) Including helpers in the main package To enable a helper, import it via relative import in the helpers/__init__.py file. This will include the functions directly in the namespace of iiif_prezi3.helpers , which in turn is imported in its entirety by the __init__.py file of the main package. In helpers/__init__.py : from .example_helper import MyHelper Allowing: >>> from iiif_prezi3 import Manifest >>> m = Manifest(id=\"https://example.com/manifest\", type=\"Manifest\", label={\"en\":\"Example Manifest\"}) >>> m.helper_function() 'I am a Manifest helper'","title":"Helper methods"},{"location":"write-helper-method/#helper-methods","text":"Helper methods in iiif-prezi3 allow functionality for common use cases to be included in the package. Helpers that are general can be loaded and used by the user as required, and those that target specific schema objects (e.g a helper to add a Canvas to a Manifest) are monkeypatched onto the relevant schema class at load time.","title":"Helper methods"},{"location":"write-helper-method/#location-and-structure","text":"Helper methods should be located in Python files inside the helpers/ directory. Direct helper methods that take schema objects as arguments can be singular functions, whereas those which are designed to add new functions or properties to existing schema classes must themselves be containing inside a class, to enable them to be monkeypatched in correctly.","title":"Location and structure"},{"location":"write-helper-method/#accessing-schema-objects","text":"Relevant schema classes can be loaded from the skeleton.py file in the main iiif-prezi3 package by using a relative import: from ..skeleton import Manifest","title":"Accessing Schema Objects"},{"location":"write-helper-method/#monkeypatching-onto-schema-classes","text":"If the helper targets a class from the main IIIF Presentation 3 schema, then it can be monkeypatched onto that class at runtime using the iiif_prezi3.loader.monkeypatch_schema() method. This function takes two arguments: the class to target, and the class(es) containing the helper methods, either as a single object or a list. Add the monkeypatch function call at the end of your helper file, and it will be run when the helper file is imported by the main package (as detailed below). from ..skeleton import Manifest from ..loader import monkeypatch_schema class MyHelper : def helper_function ( self ): return \"I am a Manifest helper\" monkeypatch_schema ( Manifest , MyHelper )","title":"Monkeypatching onto Schema classes"},{"location":"write-helper-method/#including-helpers-in-the-main-package","text":"To enable a helper, import it via relative import in the helpers/__init__.py file. This will include the functions directly in the namespace of iiif_prezi3.helpers , which in turn is imported in its entirety by the __init__.py file of the main package. In helpers/__init__.py : from .example_helper import MyHelper Allowing: >>> from iiif_prezi3 import Manifest >>> m = Manifest(id=\"https://example.com/manifest\", type=\"Manifest\", label={\"en\":\"Example Manifest\"}) >>> m.helper_function() 'I am a Manifest helper'","title":"Including helpers in the main package"}]}